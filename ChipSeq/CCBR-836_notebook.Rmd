---
title: "CCBR-836: ChipSeq Analysis of Nanog Peaks in HGMN KO model"
output: html_notebook
---


```{r}
setwd("/Users/maggiec/GitHub/Maggie/ccbr836/")
load(".RData")
library(csaw)
library(edgeR)
library(GenomicRanges)
library(genomation)
target=readTargets()
bam.files=target$files


```

```{r Correlation Plots}

#Bring in MACS peak files:

colnames=c("chrom","start","stop","name","integer_score","none","foldchange",
           "neg.log10.pval","neg.log10.qval","relative summit to peak")
KO1_peaks=read.table("KO1_peaks.narrowPeak",col.names = colnames)
KO2_peaks=read.table("KO2_peaks.narrowPeak",col.names = colnames)
WT1_peaks=read.table("WT1_peaks.narrowPeak",col.names = colnames)
WT2_peaks=read.table("WT2_peaks.narrowPeak",col.names = colnames)

KO1_peaks.gr=GRanges(KO1_peaks)
KO2_peaks.gr=GRanges(KO2_peaks)
WT1_peaks.gr=GRanges(WT1_peaks)
WT2_peaks.gr=GRanges(WT2_peaks)

KO1num=dim(KO1_peaks)[1]; KO1_tot=sum(KO1_peaks$integer_score); 
KO2num=dim(KO2_peaks)[1]; KO2_tot=sum(KO2_peaks$integer_score)
WT1num=dim(WT1_peaks)[1]; WT1_tot=sum(WT1_peaks$integer_score)
WT2num=dim(WT2_peaks)[1]; WT2_tot=sum(WT2_peaks$integer_score)

total.df$macspeaks=c(0,KO1num,KO2num,WT1num,WT2num,0)
total.df$macstots=c(0,KO1_tot,KO2_tot,WT1_tot,WT2_tot,0)
for (i in 1:6){
  dat=total.df$macstots[i]/total.df$total[i]
  total.df$ratio[i]=dat
}

total.df.lim=total.df[2:5,]
total.df.lim

makeplot(total.df.lim$total,total.df.lim$macspeaks,"Reads","Peaks","macstotalpksperreads.png")
makeplot(total.df.lim$macstots,total.df.lim$macspeaks,"macstotalpeaks.png")
makeplot(total.df.lim$total,total.df.lim$macstots,"macstotalpksperreads.png")
makeplot(total.df.lim$total,total.df.lim$ratio,"Reads","ratio","macstotalratio.png")

makeplot <- function(a,b,c,d,e) {
  xmin=min(a)-100
  xmax=max(a)+5e6
  ymin=min(b)-1000
  ymax=max(b)+1000
ggplot(total.df.lim, aes(a, b)) + 
  geom_point(aes(color = factor(name)),size=3) + 
  theme_bw()+
  xlim(xmin,xmax) +
  ylim(ymin,ymax) +
  geom_text(aes(a, b,label=name, colour = factor(name), hjust = -0.2)) +
  labs(x = c, y = d) +
  geom_smooth(se=FALSE, method="lm", formula = "y ~ log(x)", linetype="dotted") +
  theme(legend.position="none")
ggsave(e)
}
```



```{r Profiles}

# 1. Get the profiles for pooled WT and KO peaks from MACS:

#First get the union of both WT peaks and both KO peaks, then union of all:
WTmacspeaks=GenomicRanges::union(WT1_peaks.gr,WT2_peaks.gr)
KOmacspeaks=GenomicRanges::union(KO1_peaks.gr,KO2_peaks.gr)
allmacspeaks=GenomicRanges::union(WTmacspeaks,KOmacspeaks)

for (curbam in bam.files) {
    collected1[[curbam]] <- profileSites(curbam, allmacspeaks, 
        param=param)}
profile(collected1,"MACS.all.png")

# 2. Get the profiles for pooled WT and KO peaks from MACS (TSS only)

TSSmacs=findOverlaps(allmacspeaks,prom_regions) 
allmacs.TSSpeaks=allmacspeaks[queryHits(TSSmacs),]
TSSpeaks.macs=prom_regions[subjectHits(TSSmacs),]  #Drop from 55,596 -> 4,811 overlapping promoter regions

collected2=list()
for (curbam in bam.files) {
  collected2[[curbam]] <- profileSites(curbam, allmacs.TSSpeaks, 
                  param=param)}
profile(collected2,"MACS.TSS.png")

#Get the profiles for all promoters:

collected3=list()
for (curbam in bam.files) {
  collected3[[curbam]] <- profileSites(curbam, TSSpeaks.macs, 
                      param=param)}
profile(collected3,"TSS.MACS.png")

#Function to take the aggregate of the signal:

profile <- function(x,y){
xranged <- as.integer(names(x[[1]]))
ymax=max(unlist(lapply(x ,function(x) max(x))))/3
plot.new()
png(y)
plot(xranged, (x[[1]]/w[[1]]$totals)*10e6, type="l", col="blue", xlim=c(-1000, 1000), 
     ylim=c(0,ymax),lwd=2,
     xlab="Distance (bp)", ylab="Relative coverage per base")
lines(xranged, (x[[2]]/w[[2]]$totals)*10e6, col="forestgreen", lwd=2)
lines(xranged, (x[[3]]/w[[3]]$totals)*10e6, col="grey", lwd=2)
lines(xranged, (x[[4]]/w[[4]]$totals)*10e6, col="red", lwd=2)
lines(xranged, (x[[5]]/w[[5]]$totals)*10e6, col="orange", lwd=2)
lines(xranged, (x[[6]]/w[[2]]$totals)*10e6, col="cyan", lwd=2)

legend("topleft", col=c("blue", "forestgreen", "grey","red","orange","cyan"),
       target$CellType, pch=16)
dev.off()
}
abline(v=c(-177,177), col="dodgerblue", lty=2)

```
```{r Venn Diagram}
library(Vennerable)
venn_cnt2venn <- function(venn_cnt){
  n <- which(colnames(venn_cnt)=="Counts") - 1
  SetNames=colnames(venn_cnt)[1:n]
  Weight=venn_cnt[,"Counts"]
  names(Weight) <- apply(venn_cnt[,1:n], 1, paste, collapse="")
  Venn(SetNames=SetNames, Weight=Weight)
}

#makevenn <- function(x,m,n,o,p,r) {
makevenn <- function(x,m,n,r) {
  V <- venn_cnt2venn(x$vennCounts)
  C <- compute.Venn(V,doWeights=TRUE,type="circles")
  SetLabels <- VennGetSetLabels(C)
  FaceLabels <- VennGetFaceLabels(C)
  SetLabels[SetLabels$Label==m,"x"] 
  SetLabels[SetLabels$Label==n,"x"] 
#  SetLabels[SetLabels$Label==o,"x"] 
#  SetLabels[SetLabels$Label==p,"x"] 
  C <- VennSetSetLabels(C,SetLabels)
  png(filename = r)
  plot(C)
  dev.off()
}

macspeaks=list(
KO1_peaks.macs=GRanges(KO1_peaks),
KO2_peaks.macs=GRanges(KO2_peaks),
WT1_peaks.macs=GRanges(WT1_peaks),
WT2_peaks.macs=GRanges(WT2_peaks)
)

k=c(1,2)
venn.names=as.character(names(macspeaks)[k])
res1 <- makeVennDiagram(Peaks=macspeaks[k],
                        NameOfPeaks=venn.names)
makevenn(res1,venn.names[1],venn.names[2],"Nanog_KO_Venn_MACS.png")


k=c(3,4)
venn.names=as.character(names(macspeaks)[k])
res2 <- makeVennDiagram(Peaks=macspeaks[k],
                        NameOfPeaks=venn.names)
makevenn(res2,venn.names[1],venn.names[2],"Nanog_WT_Venn_MACS.png")


groupedmacspeaks=list(
  WT1.2macs=WTmacspeaks,
  KO1.2macs=KOmacspeaks,
  WT.KO=allmacspeaks)

k=c(1,2)
venn.names=as.character(names(groupedmacspeaks)[k])
res2 <- makeVennDiagram(Peaks=groupedmacspeaks[k],
                        NameOfPeaks=venn.names)
makevenn(res2,venn.names[1],venn.names[2],"Nanog_WT_KO_Pooled_Venn_MACS.png")

#Do overlaps with TSS:
KO1_TSSmacspeaks=subsetByOverlaps(KO1_peaks.gr,prom_regions)
KO2_TSSmacspeaks=subsetByOverlaps(KO2_peaks.gr,prom_regions)
WT1_TSSmacspeaks=subsetByOverlaps(WT1_peaks.gr,prom_regions)
WT2_TSSmacspeaks=subsetByOverlaps(WT2_peaks.gr,prom_regions)

TSSmacspeaks=list(
  KO1_TSS_macs=KO1_TSSmacspeaks,
  KO2_TSS_macs=KO2_TSSmacspeaks,
  WT1_TSS_macs=WT1_TSSmacspeaks,
  WT2_TSS_macs=WT2_TSSmacspeaks
)

k=c(1,2)
venn.names=as.character(names(TSSmacspeaks)[k])
res1 <- makeVennDiagram(Peaks=TSSmacspeaks[k],
                        NameOfPeaks=venn.names)
makevenn(res1,venn.names[1],venn.names[2],"Nanog_KO_TSS_Venn_MACS.png")

k=c(3,4)
venn.names=as.character(names(TSSmacspeaks)[k])
res2 <- makeVennDiagram(Peaks=TSSmacspeaks[k],
                        NameOfPeaks=venn.names)
makevenn(res2,venn.names[3],venn.names[4],"Nanog_WT_TSS_Venn_MACS.png")


WTTSSmacspeaks=GenomicRanges::union(WT1_TSSmacspeaks,WT2_TSSmacspeaks)
KOTSSmacspeaks=GenomicRanges::union(KO1_TSSmacspeaks,KO2_TSSmacspeaks)
allTSSmacspeaks=GenomicRanges::union(WTTSSmacspeaks,KOTSSmacspeaks)

groupedTSSmacspeaks=list(
  WT1.2_TSS_macs=WTTSSmacspeaks,
  KO1.2_TSS_macs=KOTSSmacspeaks,
  WT.KO=allmacspeaks)

k=c(1,2)
venn.names=as.character(names(groupedTSSmacspeaks)[k])
res2 <- makeVennDiagram(Peaks=groupedTSSmacspeaks[k],
                        NameOfPeaks=venn.names)
makevenn(res2,venn.names[1],venn.names[2],"Nanog_WT_KO_TSS_Venn_MACS.png")


TSSmacs=findOverlaps(allmacspeaks,prom_regions) 


```


```{r MA Plot}

######Find the sites from each dataset, to plot MA plots##########

#First normalize by total counts
count.ip=assays(reg.counts.tss)$counts  #4811 rows
colnames(count.ip)=target$CellType
count.tot=apply(count.ip,2,sum)
#count.tot=reg.counts.tss$totals

rows=dim(count.ip)[1]
cols=dim(count.ip)[2]
norm.ip = data.frame(matrix(NA, nrow = rows, ncol = cols))
colnames(norm.ip)=target$CellType

#Convert counts to logcpm:
for (i in 1:6){ 
  dat <- data.frame(log2((count.ip[,i]/count.tot[i])*10e6))
  norm.ip[,target$CellType[i]] <- dat
}


#Then do loess normalization:

df.m=melt(as.data.frame(norm.ip))
df.m=melt(as.data.frame(norm3.ip.filt))

ggplot(df.m, aes(x=value, group=variable)) + 
  geom_density(aes(colour = variable, linetype = variable),
               size=1, alpha=.60, kernel='epanechnikov') +
  xlab(NULL) + ylab(NULL) +
  theme(legend.position='right') + scale_x_log10() + 
  ggtitle("Normalized Counts by total counts") 
ggsave(file="total_cpm_norm_dist.png")


filt=apply(norm.ip,1,function(x) sum(x)!=-Inf)
norm.ip.filt=norm.ip[filt,]
norm.ip.filt %>% rowwise() %>% mutate(mean_KO=mean(Nanog_KO1,Nanog_KO2),
                mean_WT=mean(Nanog_WT1,Nanog_WT2)) -> norm.ip.filt

MAplotcloud(norm.ip.filt,2,3,"KO-MA.TSS.png","KO1-KO2 total counts norm")
MAplotcloud(norm.ip.filt,4,5,"KO-WT.TSS.png","WT1-WT2 total counts norm")
MAplotcloud(norm.ip.filt,7,8,"KO-WT-mean-MA.TSS.png","meanKO-meanWT total counts norm")

MAplotcloud <- function(l,m,n,p,q){
adjc <- l
abval <- as.matrix(adjc[,m]+adjc[,n])
o <- order(abval)
mval <- as.matrix(adjc[,m]-adjc[,n])
ymax=max(mval)
xmax=max(abval)
fit <- loessFit(x=abval, y=mval)
png(filename=p)
smoothScatter(abval, mval, ylab="M", xlab="Average logCPM",
            main=q, ylim=c(-ymax,ymax))
lines(abval[o], fit$fitted[o], col="red")
lines(c(0,xmax),c(0,0),col="blue")
dev.off()
}

norm2.ip.filt=normalizeCyclicLoess(norm.ip.filt[,2:5], weights = NULL, 
                  span=0.7, iterations = 3, method = "fast")
norm2.ip.filt=as.data.frame(norm2.ip.filt)
norm2.ip.filt %>% rowwise() %>% mutate(mean_KO=mean(Nanog_KO1,Nanog_KO2),
                mean_WT=mean(Nanog_WT1,Nanog_WT2)) -> norm2.ip.filt

MAplotcloud(norm2.ip.filt,5,6,"KO-WT-mean2-MA.TSS.png","Loess-normalized2")

count.off <- normOffsets(as.matrix(norm.ip.filt)[,2:5], type="loess")

#Repeating after normalization.
rows=dim(norm2.ip.filt)[1]
cols=dim(norm2.ip.filt)[2]-2
norm3.ip.filt = data.frame(matrix(NA, nrow = rows, ncol = cols))
colnames(norm3.ip.filt)=target$CellType[2:5]
  
for (i in 1:4){ 
  dat <- data.frame(norm2.ip.filt[,i])-count.off[,i]
  norm3.ip.filt[,i] <- dat
}

norm3.ip.filt %>% rowwise() %>% mutate(mean_KO=mean(Nanog_KO1,Nanog_KO2),
      mean_WT=mean(Nanog_WT1,Nanog_WT2)) -> norm3.ip.filt
MAplotcloud(norm3.ip.filt,5,6,"KO-WT-mean3-MA.TSS.png","Loess-normalized")


finalres=cbind(as.data.frame(rowRanges(reg.counts.tss)[filt,]),norm3.ip.filt)



```

